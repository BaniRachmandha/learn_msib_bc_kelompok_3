const fs = require("fs");
const path = require("path");
const proc = require("process");
const ary_split = require("nv-array-split");
const {is_truthy} = require("nv-facutil-basic");


const is_alias_key = (s) =>(s[0]==='-' && s[1]!=='-')

const is_full_key  = (s) =>(s[0]==='-' && s[1]==='-')

const is_key       = (s) => (s[0]==='-')

function split(ary=process.argv.slice(2)) {
    ary = ary_split.slc(ary,[is_alias_key,is_full_key])
    let nary =[]
    for(let each of ary) {
        if(is_key(each[0])) {
            nary = nary.concat(each.map(r=>[r]))
        } else {
            nary.push(each)
        }
    }
    return(nary)
}


const kcond_func = (l,condf=is_key) => l.length===1 && condf(l[0])

function deflat(splitted,kcondf=kcond_func,dflt_key='_') {
    if(splitted.length===0) {
        return([dflt_key,[]])
    } else {
        let fst = splitted[0];
        let ary;
        let rslt = [];
        if(!kcondf(fst)) {
            rslt.push(dflt_key,fst);
            ary = splitted.slice(1)
        } else {
            ary = splitted;
        }
        ////
        let c = 0;
        let state = 'init'
        let k;
        let v;
        while(c<ary.length) {
            let list = ary[c]
            if(state === 'init') {
                if(list.length===1 && is_key(list[0])) {
                    state = 'key';
                    k = list[0]
                } else {
                    //impossible
                }
            } else if(state === 'key') {
                if(list.length===1 && is_key(list[0])) {
                    v = [];
                    rslt.push(k,v);
                    state = 'key';
                    k = list[0];
                    v = undefined;
                } else {
                    v = list;
                    state = 'value'
                }
            } else {
                //state === value
                if(list.length===1 && is_key(list[0])) {
                    rslt.push(k,v);
                    state = 'key';
                    k = list[0];
                    v = undefined;
                } else {
                    //impossible
                }
            }
            c = c +1;
        }
        ////
        if(k!==undefined) {
            if(v === undefined) {
                rslt.push(k,[])
            } else if(v !== undefined) {
                rslt.push(k,v);
            }
        } else {
        }
        ////
        return(rslt)
    }
}

function get_md(alias_d) {
    let aks = Object.keys(alias_d);
    let fks = Object.values(alias_d);
    let entries = fks.map((r,i)=>[r,aks[i]]);
    let amd = Object.fromEntries(entries)
    return(amd)
}

function to_dict_asgn(d,k,v,alias_d,amd) {
    if(is_alias_key(k)) {
        let rak = k.slice(1);
        d[rak] = v;
        let rfk = amd[rak];
        if(rfk!==undefined) {d[rfk] = v;}
    } else if(is_full_key(k)) {
        let rfk = k.slice(2);
        d[rfk] = v;
        let rak = alias_d[rfk];
        if(rak!==undefined) {d[rak] = v;}
    } else {
        //impossible
    }
    return(d)
}


function to_dict(deflatted,alias_d,amd) {
    amd = amd??get_md(alias_d);
    let d = {}
    for(let i =0;i<deflatted.length-1;i=i+2) {
        let k = deflatted[i];
        let v = deflatted[i+1];
        to_dict_asgn(d,k,v,alias_d,amd);
    }
    d._ = deflatted[0]==='_'?deflatted[1]:[];
    return(d)
}



function fmt_asgn(d,k,alias_cfg,amd) {
    if(k in alias_cfg) {
        let ak = alias_cfg[k];
        d[ak] = d[k];
    } else if(k in amd) {
        let fk = amd[k];
        d[fk] = d[k];
    } else {}
    return(d)
}


function fmt_d(___vard___, alias_cfg, bl_cfg, str_cfg, dflt_cfg, amd) {
  amd = amd ?? get_md(alias_d);

  for (let k in dflt_cfg) {
    if (!___vard___.hasOwnProperty(k)) {
      ___vard___[k] = dflt_cfg[k];
    }
  }

  for (let k in ___vard___) {
    fmt_asgn(___vard___, k, alias_cfg, amd);
  } ////


  for (let k in ___vard___) {
    if (k in amd) {
      delete ___vard___[k];
    }
  } ////


  for (let k in ___vard___) {
    if (___vard___[k] instanceof Array) {
      if (___vard___[k].length === 0) {
        if (k in dflt_cfg) {
          ___vard___[k] = dflt_cfg[k];

          if (k in str_cfg) {
            ___vard___[k] = String(___vard___[k]);
          } else if (k in bl_cfg) {
            ___vard___[k] = false;
          } else {}
        } else {
          if (str_cfg.includes(k)) {
            ___vard___[k] = "";
          } else if (bl_cfg.includes(k)) {
            ___vard___[k] = true;
          } else {
            ___vard___[k] = undefined;
          }
        } ////


        fmt_asgn(___vard___, k, alias_cfg, amd);
      } else if (___vard___[k].length === 1) {
        if (str_cfg.includes(k)) {
          ___vard___[k] = ___vard___[k][0];
        } else if (bl_cfg.includes(k)) {
          try {
            ___vard___[k] = is_truthy(eval(___vard___[k][0]));
          } catch (e) {
            ___vard___[k] = is_truthy(___vard___[k][0]);
          }
        } else {
          try {
            ___vard___[k] = eval(___vard___[k][0]);
          } catch (e) {
            ___vard___[k] = ___vard___[k][0];
          }
        } ////


        fmt_asgn(___vard___, k, alias_cfg, amd);
      } else {
        if (str_cfg.includes(k)) {} else if (bl_cfg.includes(k)) {
          let arr = [];

          for (let r of ___vard___[k]) {
            try {
              r = eval(r);
            } catch (e) {
              r = r.length === 0 ? false : true;
            }

            r = is_truthy(r);
            arr.push(r);
          }

          ___vard___[k] = arr;
        } else {
          let arr = [];

          for (let r of ___vard___[k]) {
            try {
              r = eval(r);
            } catch (e) {
              r = r;
            }

            arr.push(r);
          }

          ___vard___[k] = arr;
        } ////


        fmt_asgn(___vard___, k, alias_cfg, amd);
      }
    } else {}
  }

  for (let k in alias_cfg) {
    if (k in ___vard___) {} else {
      if (k in dflt_cfg) {
        ___vard___[k] = dflt_cfg[k]; ////

        if (str_cfg.includes(k)) {
          ___vard___[k] = "";
        } else if (bl_cfg.includes(k)) {
          ___vard___[k] = false;
        } else {}
      } else {
        ////
        if (str_cfg.includes(k)) {
          ___vard___[k] = "";
        } else if (bl_cfg.includes(k)) {
          ___vard___[k] = false;
        } else {
          ___vard___[k] = undefined;
        }
      }
    }

    fmt_asgn(___vard___, k, alias_cfg, amd);
  }

  return ___vard___;
}

function _creat_cls(cfg) { 
    class Argv {
        #alias   = {}
        #boolean = []
        #string  = []
        #defaults = {}
        #description = {}
        constructor() {
            this.#alias   = cfg.alias??{};
            let amd = get_md(this.#alias);
            let alias = this.#alias;
            this.#boolean = cfg.boolean??[];
            this.#boolean.forEach(r=>{
                if((r in alias)){this.#boolean.push(alias[r])}
                if((r in amd)){this.#boolean.push(amd[r])}
            });

            this.#string  = cfg.string??[];
            

            this.#string.forEach(r=>{
                if((r in alias)){this.#string.push(alias[r])}
                if((r in amd)){this.#string.push(amd[r])}
            });


            this.#defaults = cfg.defaults??{};
            for(let k in this.#defaults) {
                if(k in alias) {this.#defaults[alias[k]] = this.#defaults[k]}
                if(k in amd) {this.#defaults[amd[k]] = this.#defaults[k]}
            }

            this.#description = cfg.description??{};
        }
        get alias_ ()   {return(this.#alias)}
        get amd_   ()   {return(get_md(this.#alias))}
        get boolean_()  {return(this.#boolean)}
        get string_()   {return(this.#string)}
        get defaults_()  {return(this.#defaults)}
        get description_() {return(this.#description)}
        get cfg_()      {return({
            alias:this.#alias,
            boolean:this.#boolean,
            string:this.#string,
            defaults:this.#defaults,
            description:this.#description,
        })}
        usage(name,prefix='',suffix='') {
            let head = prefix + `Usage: ${name} [options] ` + suffix;
            let opt_head = `Options:`;
            let fks = Object.keys(this.#description);
            let max_lngth = Math.max(...fks.map(r=>r.length))
            let aks = fks.map(
                fk=> {
                    let ak = this.#alias[fk]??'?';
                    return(ak)
                }
            );
            let nfks = fks.map(r=>r+" ".repeat(max_lngth-r.length));
            let lines = fks.map(
                (fk,i) => 
                    '    ' +'-' +aks[i] +', ' + 
                    '--'+nfks[i]+'        ' + this.#description[fk]
            )
            lines.unshift(opt_head);
            lines.unshift(head);
            return(lines.join('\n')+'\n')
        }
        ////
        input_stream(input,encoding='utf8') {
            let rs$;
            if(input) {
                rs$ = fs.createReadStream(input,{encoding:encoding});
            } else {
                rs$ = process.stdin;
            }
            return(rs$)
        }
        ////
        output_stream(input_rs$,handler=(r)=>r,output) {
            let rs$ = input_rs$;
            let s = '';
            rs$.on('data',data=>{s=s+data});
            rs$.on(
                'end',
                ()=>{
                    let rslt = handler(s);
                    if(!output) {
                        let ws$ = process.stdout;
                        ws$.write(rslt+'\n\n')
                    } else {
                        fs.writeFileSync(path.resolve(output),rslt)
                    }
                }
            )
        }
        ////
        rwstream(handler=(r)=>r,input,output,input_encoding='utf8') {
            let rs$ = this.input_stream(input,input_encoding);
            this.output_stream(rs$,handler,output);
        }
        ////
        pre_post_tem(pre_brotli_files=[],post_brotli_files=[]) {
            let tem = `
//package.json
{
    scripts: {
        "preinstall":"node preinstall.js",
        "postinstall":"node postinstall.js",
    }
}
//preinstall.js  postinstall.js

const path = require("path")
const {
    decompress_str,
    decompress_json,
} =require("nv-facutil-compress").cli;
`;

            let pres = ['//preinstall.js'];
            pre_brotli_files.forEach(
                d => {
                    if(d.type==='str') {
                        pres.push(`decompress_str(path.resolve(__dirname+"${d.name}"))`)
                    } else {
                        pres.push(`decompress_json(path.resolve(__dirname+"${d.name}"))`)
                    }
                }
            )
            tem = tem + pres.join("\n") + "\n";
            let posts = ['//postinstall.js'];
            post_brotli_files.forEach(
                d => {
                    if(d.type==='str') {
                        posts.push(`decompress_str(path.resolve(__dirname+"${d.name}"))`)
                    } else {
                        posts.push(`decompress_json(path.resolve(__dirname+"${d.name}"))`)
                    }
                }
            )
            tem = tem + posts.join("\n");
            return(tem+"\n")
        }
    }
    return(Argv)
}


const {is_str,is_ary} = require("nv-facutil-basic")

const force_to_ary = (v)=>is_ary(v)?v:(is_str(v)?[v]:[]);

function creat_argv(cfg) {
    let Argv = _creat_cls(cfg);
    let argv = (new Argv());
    const {alias,boolean,string,defaults} = argv.cfg_;
    let splitted = split(process.argv.slice(2));
    let deflatted = deflat(splitted);
    let amd = get_md(alias);
    let d   = to_dict(deflatted,alias,amd);
    d = fmt_d(d,alias,boolean,string,defaults,amd);
    for(let k in d) {argv[k] = d[k]}
    Object.freeze(argv);
    return(argv)
}
creat_argv.force_to_ary = force_to_ary;


const is_true_str = (s)=> {
    s = s.toLowerCase();
    return(
        s==="y" ||
        s==='yes' ||
        s==='t' ||
        s==='true' ||
        s==='是'   ||
        s==='真'   ||
        s==='si'
    )
}

creat_argv.is_true_str = is_true_str;

const cli_prms = (p,handle=(r)=>console.log(r))=> {
    p.then(
        r=>handle(r)
    ).catch(
        err=>{console.log(err)}
    ).finally(
        ()=>{process.exit()}
    );
}

creat_argv.cli_prms = cli_prms;

const verify_name_with_ptrn = (ptrn,name)=> {
     if(ptrn === undefined) {
	 return(true)
     } else if(typeof(ptrn) === "string") {
         if(name === ptrn) { 
             return(true)
         } else {
             return(false)
         }
     } else if(ptrn instanceof RegExp) {
         if(ptrn.test(name)) {
              return(true)
         } else {
             return(false)
         }
     } else {
         if(ptrn(name)) {
             return(true)
         } else {
             return(false)
         }
     }
}
creat_argv.verify_name_with_ptrn = verify_name_with_ptrn;


const get_require_path = (fn,rel_path) => {
        fn = path.resolve(fn);
	let stat = fs.lstatSync(fn);
	if(stat.isDirectory()) {
	} else {
            fn = path.parse(fn).dir;
	}
	return(path.join(fn,rel_path))
} 

creat_argv.get_require_path = get_require_path;

const _walk = require("nv-file-sync-reader").walk;
creat_argv.walk = _walk;


const __mkdir_if_not_exist = (p)=> {
     if(fs.existsSync(p)) {
     } else {
	  fs.mkdirSync(p)
     }
}

const __touch_if_not_exist = (p)=> {
     if(fs.existsSync(p)) {
     } else {
          fs.writeFileSync(p,"")
     }       
}

const __amkdir = (base,pl,a)=> {
    for(let i=0;i<a.length;++i) {
         pl.push(i);
	 __mkdir_if_not_exist(path.join(base,pl.join("/")));
	 let j = a[i];
         if(j instanceof Array) {
	     __amkdir(base,pl,j)
	 } else if(j ===null)   {
	     __touch_if_not_exist(path.join(base,pl.join("/"),String(null)))
	 } else if(j instanceof Object){
             __dmkdir(base,pl,j)	      
	 } else {
	     __touch_if_not_exist(path.join(base,pl.join("/"),String(j)))
	 }
	 pl.pop()
    }
}
const __dmkdir = (base,pl,d)=> {
    for(let k in d) {
         pl.push(k);
	 __mkdir_if_not_exist(path.join(base,pl.join("/")));
         let j = d[k];
         if(j instanceof Array) {
             __amkdir(base,pl,j)
         } else if(j ===null)   {
             __touch_if_not_exist(path.join(base,pl.join("/"),String(null)))
         } else if(j instanceof Object){
             __dmkdir(base,pl,j)
         } else {
             __touch_if_not_exist(path.join(base,pl.join("/"),String(j)))
         }
	 pl.pop();   
    }
}


const _mkdir = (j={},base="./")=> {
     base = path.resolve(base);
     __mkdir_if_not_exist(base);
     let pl = [];
     if(j instanceof Array) {
         __amkdir(base,pl,j);
     } else if(j ===null)   {
	  __touch_if_not_exist(path.join(base,"null"))
     } else if(j instanceof Object){
          __dmkdir(base,pl,j);
     } else { 
          __touch_if_not_exist(path.join(base,String(j))) 
     }
}

creat_argv.mkdir = _mkdir;

const child_process = require("child_process");

const _run_npmcmd_until_succ = (cmd=`npm publish`)=> {
    child_process.execSync(`npm version patch`);
    while(true) {
     try {
        let r = child_process.execSync(cmd);
        break
     } catch(e) {
             
     }
    }
    if(fs.existsSync("nohup.out")){
        fs.rmSync("nohup.out")    
    }
}

creat_argv.run_npmcmd_until_succ = _run_npmcmd_until_succ

module.exports = creat_argv;
